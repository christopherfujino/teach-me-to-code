---
title: "Why It's Difficult To Judge A Programming Language"
date: 2024-08-04 00:00:00
tags: ['Programming languages']
draft: true
---

Programmers have a lot of opinions about the tools that they use.

Why most programmers are ill-equipped to evaluate the quality of programming languages:

1. Most programmers either have a low number of total apps worked on with a lot of experience maintaining and/or scaling these projects, or a high number of total apps worked on with little or no time spent maintaining them. The programmers in the former case will be biased toward language features that help with debugging, refactoring, and performance, while those in the latter case will be biased toward features that help them prototype and implement features quickly and expressively. An example dichotomy would be the former coder would prefer statically typed languages, while the latter dynamically typed.

2. Most programmers' language usage is unequally distributed. To have the least biased opinion on the quality of a programming language, it would be ideal if a programmer had an equal amount of experience across at least 10 languages that are all very different. In reality, it's more likely that a programmer would have non-trivial experience in 3 languages, all in a similar domain (e.g. three web-oriented scripting languages), and a handful of toy apps built in other languages over a weekend. When you have a lot of experience with a tool (and programming languages are ultimately tools), you underestimate the pain of its rough edges (as you've learned how to work around them) and assume its more advanced features are essential to a "good" language, because they are essential to your workflow.

3. Related to the previous point, programmers with a lot of experience with one programming language underestimate its rough edges and overestimate its powerful features and then experience the inverse bias when trying new languages.

4. Programmers are biased by the kinds of problems they solve. A filesystem driver maintainer is unlikely to be in touch with the needs of a frontend UI developer, and vice versa. Neither is likely to be too impressed with the tools of the other.

